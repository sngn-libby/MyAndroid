[toc]

<br>

### 1. Write

```java
private NdefMessage makeNdefMsg(String data, String type) {
    type = "URI";
    data = "https://www.github.com/sngn-libby";
    NdefMessage ndefMsg = null;
    if(type.equals("URI")) {
        NdefRecord urlR = NdefRecord.createUri(data); // String type을 metadata로 쓸 경우

        /* AAR Record를 넣고싶을 때
            NdefRecord aarR = NdefRecord.createApplicationRecord(getPackageName());
            NdefRecord [] recArr = new NdefRecord[] {urlR, aarR};
             */

        NdefRecord [] recArr = new NdefRecord[] {urlR}; // ndefMsg.getRecords(); // 읽을떄와 반대순서로 하면된다.
        ndefMsg = new NdefMessage(recArr);
    }

    return ndefMsg;
}
```



1. Tag를 읽기
2. 쓰려는 내용을 Overwrite하기
   - 모든 데이터는 Content Provider가 내용을 제공한다. ("content://"로 시작한다)
3. 

<br>

- estimote (Beacon Sensor)
  - TX Power : 지도 관련 일도 할 수 있따.
  - 실내측의



<br>

### 3. BLE

- BLE 통신방식

  1. 브로드캐스팅 (Beacon이 대표적)
     - 1:N의 통신이 가능하다.
     - Connection이 이루어지지 않는 것은 아니다.
     - 가벼워서 시스템에 부하를 주지 않는다.
     - 패킷에 담을 수 있는 데이터 크기의 제약이 있다. (전송데이터 크기의 제약)
     - 단점 : 보안에 취약하다. (NFC가 훨씬 안정성이 높다)
  2. Connection 방식 (IoT)
     - IoT : **Server** (데이터 제공)  
       SmartPhone : Client
     - 1:1 통신 방식에서 많이 쓰인다.
     - Beacon은 데이터 크기 제약이 있어, 다량의 데이터 교환시 Connection방식을 이용한다.
     - 브로드캐스팅한 후, 커넥션이 되자마자 브로드캐스팅을 중단한다.
     - 실시간으로 변하는 데이터를 어떻게 받아올까?  
       : 메모리, 배터리 소모 최소화시키는 것이 관건    
       1. Notify   
          (== Callback,   value 값이 변경되면 GATT client 에 알려주는 기능)  
       2. get(), set() :   
          Client가 polling하기 (값의 변화가 있는지 계속 Server에 물어보는 방식, 손실이 발생할 수 있고, 부하가 많이 걸린다.)  
          활성화 시킬때만 실행시킨다. (사용자가 Scan등의 버튼을 누를때)

- Phripheral

  - [GATT (General Attribute Profile_Protocol)]( https://blog.naver.com/sher1400/221711438168 ) :   GATT는 두 BLE 장치간에 Service, Characteristic 을 이용해서 데이터를 주고 받는 방법을 정의한 것  
    <br> ![microcontrollers_GattStructure](http://www.hardcopyworld.com/ngine/aduino/wp-content/uploads/sites/3/2014/10/microcontrollers_GattStructure.png) 

    <br>

    - Profile : 서비스의 묶음 (~~ Ndef Message)
    - Characteristic :  구성정보 - 데이터정보 - 데이터전송속도 - ... 순으로 배치된다  (~~ Ndef Record)  
      특성은 단 하나의 데이터만을 포함
    - Descriptor : 

  - peripheral : GATT server(slave) :arrow_forward: Sensor  
    게시(advertisement) 만들기

  - Central : GATT client(master) :arrow_forward: Smart Phone  
    scan, 게시검색(looking for advertisement) 담당

    - 데이터 처리 과정
      1. 주변의 BLE 장치 스캔 (GAP profile이 정의)
      2. 원하는 peripheral(센서장치)가 보이면 연결  
         --> 두 장치가 연결되면 센서장치는 advertising을 종료,  
         --> Central은 GATT client역할을 하고 GATT server에 연결됨
      3. 

  - **어떻게 접근해서, 데이터를 가져오지?**

    - 접근

      - UUID : 고유번호 ( [Universally unique identifier](https://en.wikipedia.org/wiki/Universally_unique_identifier) , 범용고유식별자)

      - Notify : 데이터

      - 센서 - 장비간 연결 (여러가지 요청이 필요)

        1. 연결하기     

           - permission 및 Location 허용하기 (기기와 SourceCode 모두)
           - 서비스 개수 묻기
           - 

           <----여기서부터(연결된이후 통신작업)는 Background 작업 ---->

        2. CallBack함수 구현하기

           - onConnectionStateChange : 정상 연결되었을 때 콜백

           - onServicesDiscovered

             ```java
             btGatt.discoverServices(); // 이 함수에서 콜백된다.
             ```

             

           - onCharacteristicRead : readCharacteristic() 시 콜백

           - onCharacteristicWrite

           - onCharacteristicChanged

        3. 연결종료시 **리소스 반환**하는 코드 반드시 쓰기 ( onPause() )

           ```java
           if(btGatt != null) { // 리소스 반납하기
               btGatt.disconnect();
               btGatt.close();
           }
           ```

           <br>

    - 데이터 (Adapter이용)

      1. notifyDataSetChanged() : 데이터 변경되었을 때 업데이트하기

         - 기존 데이터가 있는지 여부를 체크한 후 업데이트시키기

         - **notification 받기** (03.BleControl > MainActivity.java > testButton())

           1. Configuration 활성화   
              : 데이터를 수신할 구성정보(Characteristic) 기능 활성화

              ```java
              enableSensor(UUID_IRT_SERV, UUID_IRT_CONF);
              ```

           2. Notification 활성화

              ```java
              BluetoothGattCharacteristic c = gatt.getService(UUID_IRT_SERV).getCharacteristic(UUID_IRT_DATA);
              		
              gatt.setCharacteristicNotification(c, true);
              ```

           3. 데이터의 CCCD값을 활성화

              ```java
              BluetoothGattDescriptor descriptor = c.getDescriptor(UUID
              				.fromString("00002902-0000-1000-8000-00805f9b34fb"));
              if (descriptor != null) { // setValue에 1을 넣어주는 코드 (0->1)
                  byte[] val = true ? BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE
                      : BluetoothGattDescriptor.DISABLE_NOTIFICATION_VALUE;
                  descriptor.setValue(val);
                  gatt.writeDescriptor(descriptor);
              }
              if (c.getValue() != null) {
                  Log.d(LOGTAG, "testButton1 501 : " + c.getValue()[0]);
              }
              
              try {
                  Thread.sleep(100);
              } catch (InterruptedException e) {
                  // TODO Auto-generated catch block
                  e.printStackTrace();
              }
              ```

              - CCCD(discriptor)값 활성화 == setValue()에 1로 set  
                -> onCharacteristicChanged()  가 Callback된다.
              - c는 달라지지만 fromString()의 CCCD값은 동일하다 (ex. 모든 부모에대해 Humid 정보를가진 CCCD 는 "00002902-0000-1000-8000-00805f9b34fb"로 동일하다)

<br>


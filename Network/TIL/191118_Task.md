[TOC]

<br>

## 1. Task

#### 1) Activity 흐름 관리

- 각 Activity가 Task이다.
- 정적인 방법(Launch Mode) : Manifest에 설정한다
- 동적인 방법(Intent Flag) : 정적인 방법에 우선한다.

#### 2) Launch Mode

- standard

  + 호출시마다 새로운 인스턴스를 만든다.

  + FirstApp ( A -> B -> C ) -> SecondApp 호출 ( C -> D )

    ```shell
    Running activities (most recent first):
      TaskRecord{aab3cf #284 A=a.b U=0 StackId=1 sz=4}
        Run #4: ActivityRecord{a59c7ce u0 edu.jaen.android.app.task.launchMode/.D t284}
        Run #3: ActivityRecord{38fdd36 u0 edu.jaen.android.app.task.launchMode/.C t284}
        Run #2: ActivityRecord{d80df6f u0 edu.jaen.android.app.task.launchMode/.B t284}
        Run #1: ActivityRecord{2fbf57c u0 edu.jaen.android.app.task.launchMode/.A t284}
      TaskRecord{c91d15c #283 A=edu.jaen.android.app.task.launchMode2 U=0 StackId=1 sz=1
        Run #0: ActivityRecord{5d4f25a u0 edu.jaen.android.app.task.launchMode2/.E t283}
    ```

    

  +  -> Home Key -> FirstApp 호출  
    : SecondApp( D )가 보여진다.

    ```shell
        Running activities (most recent first):
          TaskRecord{f11a9a0 #92 I=com.google.android.apps.nexuslauncher/.NexusLauncherActivity U=0 Stac
    kId=0 sz=1}
            Run #0: ActivityRecord{764df75 u0 com.google.android.apps.nexuslauncher/.NexusLauncherActivi
    ty t92}
    
      Stack #5:
      mFullscreen=true
      mBounds=null
        Task id #179
        mFullscreen=true
        mBounds=null
        mMinWidth=-1
        mMinHeight=-1
        mLastNonFullscreenBounds=null
          TaskRecord{1085c65 #179 A=com.android.systemui U=0 StackId=5 sz=1}
          Intent { flg=0x10804000 cmp=com.android.systemui/.recents.RecentsActivity }
            Hist #0: ActivityRecord{ae26237 u0 com.android.systemui/.recents.RecentsActivity t179}
              Intent { flg=0x10804000 cmp=com.android.systemui/.recents.RecentsActivity }
              ProcessRecord{9f31179 14163:com.android.systemui/u0a28}
    
        Running activities (most recent first):
          TaskRecord{1085c65 #179 A=com.android.systemui U=0 StackId=5 sz=1}
            Run #0: ActivityRecord{ae26237 u0 com.android.systemui/.recents.RecentsActivity t179}
    
      ResumedActivity: ActivityRecord{a59c7ce u0 edu.jaen.android.app.task.launchMode/.D t284}
      mFocusedStack=ActivityStack{892dbc stackId=1, 2 tasks} mLastFocusedStack=ActivityStack{892dbc stac
    kId=1, 2 tasks}
    ```

  + flag로 한번에 특정 프로세스로 이동하기

    ```틔
    <activity
                android:name="D"
                android:label="@string/title_activity_d"
                android:parentActivityName=".A"
                >
            </activity>
    ```

    

- singleTop

  - **최상위 Task (Top)**를 재호출시 --> 기존인스턴스 재사용한다 (새로 만들지 않는다.)
  - `onPause() -> onNewIntent() -> onResume()`
  - `getIntent()` : 새로운 인스턴스를 만들지 않기 때문에 처음에 전달된 Intent만 가져올수있다.  
    처음에 전달된 Intent가 아닌, 새로전달된 Intent를 받기 위한 함수 --> `onNewIntent(Intent i)`
  - 이 모든건 Top위에 있을때만 가능하다.

- singleTask

  - 호출된 Activity를 시작점으로 새로운 Task를 생성

  - Task를 바꿀때 delay가 발생한다.

  - 태스크에 해당 액티비티가 하나 밖에 없어야 한다.   
    동일한 태스크가 존재하고 해당 액티비티가 태스크에 있을 시 onNewIntent()를 호출한다.   
    해당 액티비티가 없다면 태스크의 가장 위에 추가된다.   
    태스크도 없다면 새로 태스크를 생성한다.  

  - A에 LaunchMode 설정  

    ```xml
    <activity
                android:name="A"
                android:label="@string/app_name"
                android:launchMode="singleTask"
    ```

    FirstApp ( A -> B -> C ) -> SecondApp 호출 ( C -> D )  -> Home Key -> FirstApp 호출  
    : **A** (FirstApp)가 호출된다.

  - ex 1)  
    B 액티비티를 singleTask라고 설정했다고 하자. A->B->C로 호출했을 때 모두 같은 taskAffinity 값을 가진다면 태스크에 [A,B,C]가 된다. A->B->C->B 순서로 호출했을 때는 C가 제거 되고 onNewIntent가 호출되고 태스크는 [A,B] 가 된다.  

  - ex 2)  
     B 액티비티를 singleTask라고 설정했다고 하자.  만일 B의 taskAffinity만 다를 때는 A->B->C 순서로 호출했다면 [A], [B,C] 가 된다.( C는 A와 같은 태스크에 있지 않는다. )  
     C가 singleTask이거나 FLAG_ACTIVITY_NEW_TASK 플래그가 있어야 [A,C], [B]가 된다.  

- singleInstance

  - Task내에 호출된 Activity하나만 존재한다.

  - 태스크에 들어가는 액티비티는 1개 밖에 없고 액티비티 또한 백스택 안에 하나여야 한다. 

  - C에 singleInstance 설정

    ```xml
    <activity
                android:name="C"
                android:label="@string/title_activity_c"
                android:launchMode="singleInstance">
    ```

    FirstApp -> SecondApp 호출 -> Home Key -> FirstApp 호출  
    : **B** (FirstApp)이 보여진다

  - ex )  예로 B 액티비티가 singleInstance이고 A,B,C의 taskAffinity 값이 같다고 하자. A->B->C 순서로 호출했을 시 [B], [A,C]가 된다. C 액티비티에서 Back 버튼을 누를 시 A 액티비티가 보인다. 만약 C가 Dialog Activity여서 배경에 다른 액티비티가 보인다고 하면 배경으로 B가 아닌 A 액티비티가 보인다. 참고로 최근 앱 목록에서는 [B], [A,C]가 별도로 보이지 않는다. 최근 앱 목록은 taskAffinity 값을 분류 기준으로 삼기 때문이다. B의 taskAffinity 값을 다른 값으로 바꾸면 최근 앱 목록에 [B]와 [A,C]가 보인다. 

#### 3) Intent Flag

1. FLAG_ACTIVITY_SINGLE_TOP : singleTop 과 동일하다.

2. FLAG_ACTIVITY_NEW_TASK : singleTask 와 같다.

3. FLAG_ACTIVITY_CLEAR_TOP : 백스택에 [A,B,C] 가 있고 C에서 B를 시작할 때 해당 플래그가 있으면 [A,B]가 된다. 보통 FLAG_ACTIVITY_SINGLE_TOP과 같이 쓰인다. 같이 쓰면 B를 시작할 때 onNewIntent()메서드가 호출되고 같이 안 쓰면 onCreate()가 호출된다. 만약 [A,B,A,B] 백스택 일 때 CLEAR_TOP 플래그로 A를 시작한다면 [A,B,A]가 된다. [A]가 되려면 <activity-alias>를 사용해야 한다.
4. FLAG_ACTIVITY_CLEAR_TASK : 피호출자 액티비티가 시작하기 전에 관련된 스택이 모두 제거되고 피호출자 액티비티가 빈 태스크의 맨 아래에 놓인다. 보통 FLAG_ACTIVITY_NEW_TASK와 같이 사용된다. 예로 앱을 사용할 때 로그아웃하고 다른 아이디로 로그인하면 기존 태스크를 정리하고 새로운 메인 액티비티를 실행해야 한다. 이 때 두 플래그를 같이 사용한다.
5. FLAG_ACTIVITY_REORDER_TO_FRONT : 스택에 동일한 액티비티가 있다면 그 액티비티를 스택의 맨 위로 올린다. 단 FLAG_ACTIVITY_CLEAR_TOP과 같이 사용 못 한다. 





<br>

## 2. NFC (106p)

- 결제와 관련한 기능 -> 자동으로 켤수있는 기능을 막아두었다  
  블루투스는 자동으로 켤 수 있다.

- 묵시적 Intent를 사용한다 : 각 액션에게 TAG를 처리할 수 있는지 물어본 후 -> 인텐트를 보낸다.

- Intent처리 Activity (106p)

  1. NDEF_DISCOVERED
  2. TECH_DISCOVERED : ex) Tab and Pay
  3. TAG_DISCOVERED

  ```xml
  <activity android:name=".MainActivity">
      <intent-filter>
          <action android:name="android.intent.action.MAIN" />
  
          <category android:name="android.intent.category.LAUNCHER" />
      </intent-filter>
      <intent-filter>
          <action android:name="android.nfc.action.NDEF_DISCOVERED" />
  
          <category android:name="android.intent.category.DEFAULT" />
      </intent-filter>
  </activity>
  ```

- NDEF record : NFC에서 다루는 가장 작은 데이터의 단위  
  : NDEF message는 NDEF record의 묶음으로 되어있다.

- NDEF message > NDEF record > NDEF tag > 데이터 끄집어내기



<br>

## 3. ForeGround로 구현하기 (111p)

1. Permission 주기 (manifest)

   ```xml
   <uses-permission android:name="android.permission.NFC"/>
   <application
   ```

2. 인텐트 생성하기  
   프레임워크에서 인텐트 전달 > **처리할 액티비티를 호출**할 인텐트 생성

   ```java
   Intent i = new Intent(this, this.getClass());
   ```

   - getClass() : reflection API (Class 가져오기)

   ```java
   i.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
   ```

   - SingleTop으로 플래그 설정하기

3. 펜딩인텐트 생성 : 인텐트 처리할 펜딩인텐트

   ```java
   pIntent = PendingIntent.getActivity(this, 0, i, 0);
   ```

4. 인텐트필터 생성하기

   ```java
   IntentFilter ndefFilter1 = new IntentFilter(NfcAdapter.ACTION_NDEF_DISCOVERED);
   IntentFilter ndefFilter2 = new IntentFilter(NfcAdapter.ACTION_NDEF_DISCOVERED);
   IntentFilter ndefFilter3 = new IntentFilter(NfcAdapter.ACTION_NDEF_DISCOVERED);
   ```

5. 인텐트필터 설정하기

   ```java
   ndefFilter1.addDataType("text/plain");
   ndefFilter2.addDataType("https");
   ndefFilter3.addDataType("http");
   
   IntentFilter[] filters = new IntentFilter[] {ndefFilter1, ndefFilter2, ndefFilter3};
   ```

6. Task 생성시 (Activate)

   ```java
   @Override
   protected void onResume() {
     super.onResume();
     nfcAdapter.enableForegroundDispatch(this, pIntent, filers, null);
   }
   ```

   - enableForegroundDispatch() : 마지막 인자값을 null로 주면 모든 권한을 다 승인한다는 뜻이다.

7. Task 정지시 (UnActivate)

   ```java
   @Override
   protected void onPause() {
     super.onPause();
     nfcAdapter.disableForegroundDispatch(this);
   }
   ```

8. Top Activity 재호출 

   ```java
   @Override
   protected void onNewIntent(Intent intent) {
     super.onNewIntent(intent);
     processIntent(intent);
   }
   ```

9. Method 만들기

   ```java
   private void processIntent(Intent i) {
     Parcelable [] rawData = i.getParcelableArrayExtra(NfcAdapter.EXTRA_NDEF_MESSAGES);
     NdefMessage ndefMsg = (NdefMessage) rawData[0];
     NdefRecord[] rawRecords = ndefMsg.getRecords();
     NdefRecord textRcd = rawRecords[0];
     byte[] recB = textRcd.getType();
     String recType = new String(recB);
     
     if(recType.equals("T")) {
       byte[] bData = textRcd.getPayload();
       String sData = new String(bData, 3, bData.length-3);
       infoTv.setText(sData+"\n");
     } else if(recType.equals("U")) {
       Uri recUi = textRcd.toUri();
       infoTv.setText(recUi.toString());
     } else {}
   }
   ```

   
*4대컴포넌트*

# Index

<br>

[toc]

<br>

## Intent

<br>

### 1. Intent(--> ActionManager + PackageManager)에 담을 수 있는 정보 (69p)

- Component Name : 특정 컴포넌트를 **명시적으로 호출**할 때 사용한다.

  ```java
  // 호출하는 주체 클래스
  ComponentName cpName = new ComponentName("com.sm.secondapp", "com.sm.secondapp.MainActivity");
  Intent i2 = new Intent();
  i2.setComponent(cpName);
  startActivity(i2);
  
  // 호출 대상(SecondApp의 TestActivity)의 Manifest
  <activity android:name=".TestActivity"></activity> // ==> 호출할 수 없다
      
  // 호출시 ---> Caused by: java.lang.SecurityException: Permission Denial: starting Intent { cmp=com.sm.secondapp/.TestActivity } from ProcessRecord{89922d7 13497:com.sm.firstapp/u0a86} (pid=13497, uid=10086) not exported from uid 10085 에러발생
      
  // 명시적 호출시 -> android:exported="true"를 속성에 추가한다
  <activity android:name=".TestActivity" android:exported="true"></activity>
  // 묵시적 호출시 -> intent-filter (묵시적호출시에만 이걸 확인한다.)
  <activity android:name=".MainActivity">
      <intent-filter>
      	<action android:name="android.intent.action.MAIN" />
          <category android:name="android.intent.category.LAUNCHER" />
      </intent-filter>
  </activity>
              
  // 같은 프로세스(같은앱)에서 다른 컴포넌트 **명시적** 호출 (다른 프로세스 호출 불가)
  Intent i = new Intent(this, A1_Activity.class);
  i.putExtra("path", "mySDcard/myData.dat");
  ```

  

- Action - 묵시적 호출  
  : 받은 Intent로 어떤 작업을 할지

- Category - 묵시적 호출  
  : 어떤 작업영역인지 (ex. Home)

- Data - 묵시적 호출  
  : Action에 필요한 상세 데이터 제공

- Extras ★

- Flags  
  : Activity 의 흐름 제어 (여러 Intent를 동시에 종료시키거나 실행시킬 수 있다.)
  : 속성, history 등을 조건으로 걸 수 있다.

<br>

### 2. Intent Filter(73p)

- 각각의 Activity --> intent filter 가짐 --> 구현 --> manifest에 등록된다.

<br>
<br>

## Activity

<br>

### 1. Activity 상태 (53p)

- Active/Running Status : 프로세스 시작 (생성될 때) Callback(Framework가 호출)함수  
  : 자원을 할당하는 코드를 포함한다
  - ★onCreate()
  - onStart()
  - ★onResume() : 가장 중요한 활성화함수 (활성화시 거의 **무조건 callback**된다.)
- Paused Status : callback함수  
  : 자원을 반환하는 코드를 포함한다.
  - ★onPause() : 가장 중요한 비활성화함수 (비활성화시 거의 무조건 callback된다.), **상태정보**를 저장하는 코드를 포함해야한다. (shutdown될 수 있기 때문에 stopped에 저장하지 않는다.)
  - onResume() : 다시 Active Status가 될 때 callback된다. (Activity 를 Dialogue로 만들때 사용된다)
- Stopped Status : callback함수  
  : 화면에 안보이게 되는 상태
  - onStop()
  - onRestart() -> onStart() -> onResume() : 다시 Active Status가 될 때 callback된다.
- shutdown (back키를 눌렀을 때) : callback함수  
  : 우선순위 낮은것부터 kill된다.
  - onDestroy();

>Paused Status -> shutdown Status 시 Callback함수  
>  : 리소스가 부족할 때 강제로 우선순위가 낮은 Paused Status Processor를 kill시키는 함수가 callback된다.

<br>

### 2. Processor (우선순위순)

- Foreground Processor : 눈에 보이고, 조작 가능한 프로세스
- Visible Processor : 눈에 보이지만 조작 불가능한 프로세스 (Paused Status)
- Service Processor : 우선순위관리?
- Background Processor : home 키를 눌렀을때 프로세스가 모두 백그라운드로 가게된다. (시간이 오래걸리는 작업은 모두 Background 프로세서로 돌린다)
- Empty Processor

<br>

### 3. Activity LifeCycle (55p)

- `adb shell dumpsys activity`를 cmd에 입력하면 Process Life Cycle이 우선순위별로 로딩되는 상황을 확인할 수 있다.
- 프로세스 시작 -> 프로세스 Activate -> back으로 프로세스에서 나가기 (종료상태가 아닌, Empty Process == **Cached Process**상태이다)

<br>
<br>

## Service Component(57p, 215p)

- background로 실행되는 작업
- 주로 Activity에서 Start시킨다.
- 작업이 끝났다고 저절로 멈추지 않는다.
  - Intent로 종료시키기 (stopService(i))
  - stopself() 메서드로  스스로 종료시킨다.

<br>

<br>

## Broadcast Receiver(62p) ★ 잘모르겠다

- Notification 등이 모두 BroadCast Receiver이다.

- Intent이다.

- 필요할때 활성화 시킬 수 있다.

- `sendBroadcast(new Intent());` --> 시스템의 어딘가에 브로드캐스트를 처리할 수 있는 BR이 있으면 거기서 처리된다.  
  송신자에 따라서 filtering 적용이 필요하다 (보안)

- Intent  생성해서 보내기 -> Action명에 Broadcast명을 넣어준다 ->  Intent의 Extra에 어떤장비에 대한 Broadcast인지 넣어주기

- Notification Manager와 연동된다.

- Context와 상속관계가 아니다. (Toast 쓸 때 this로 넘겨줄 수 없다.)

  ```java
  Toast.makeText(context, "", Toast.LENGTH_SHORT).show();
  ```

- BroadCast의 정체는 Intent --> Intent Filter 필요하다 (action명만 등록하면 된다.)

  ```xml
  <receiver
  	android:name=".MyReceiver"
      android:enabled="true"
  	android:exported="true">
      <intent-filter>
          <action android:name="android.provider.Telephony.SMS_RECEIVED" />
      </intent-filter>
  </receiver>
  ```

  - Message 보낼 때 : SMS Manager
  - Message 받을 때 : SMS

- 비콘

- BroadcastReceiver는 동적으로 등록할 수 있다.

- 하나의 브로드캐스트 리시버가 여러대의 장비를 받아야할 때 (1:N)

  ```java
  filter.addAction("edu.scsa.action.Connection_Fail");
  ```



<br>

<br>

## UI (79p)

- Android에서 어떻게 List를 표현하는지가 중요하다.
- 구성요소
  - UI Component (Button, CheckBox, ...)
  - Container (Frame, Panel, ...)
  - Layout Manager (arrange)
- 패딩과마진
  - View ~ View 사이 간격 : 마진
  - 뷰 안의 간격(여백) : 패딩
- 구현 순서 (94p) :   
  Event Source , Type 결정   
  -> Event Handler (this, nested, anonymous) 구현   
  -> Event Source에 Event Handler 등록시키기


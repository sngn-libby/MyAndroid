### 1. 이벤트 만드는법

- this
- 익명 InnerClass
- onClick



<br>

- 시간이 걸리는 작업은 back process로 돌리기
- **options menu활용법**
- **data storage**
- NFC
- BLE, Beacon

<br>

- fragment : 자식Activity
  - Content Provider (CP: 다른 곳의 데이터를 가져올 수 있다)



<br>

### ANR (Application Not Responding)

<br>
*TestThread.java*

- Thread + WakeupNotify
- 데이터의 무결성을 위한 안드로이드의 장치  
  : Only the original thread that created a view hierarchy can touch its views. (만든애(**메인쓰레드**)만 접근가능)
- Background Thread는 핸들러이용★ (intent와 비슷한 개념)
  1. Message Type (Send계열 전달) --> Looper -> handleMessage()실행 (여러개의 Thread가 돌고있을 때)
  2. Runnable Type (Post 계열 전달) --> Looper -> run()실행 (**MainThread가 실행**) // 여기서 run() override했지만, Thread가 아니다.(Runnable을 implements받은 익명 개체이다. (run != Thread, 필수요소일뿐)) (잠깐 실행할때)
  3. runOnUiThread (compiler에서 알아서 Message, Runnable 중에 하나로 판단해서 컴파일시켜줌)
- Main Thread
  - Looper는 Handler에서넘어온 데이터인 message, runnable type을 Q에 전달하는 역할을 한다. (MainThread 자체적으로 수행)
  - Handler 의 handleMessage()로 메세지를 가져온다.
  - Intent간 데이터공유는 Component를 통해서
  - Thread간 데이터공유는 Handler를 통해서
  - Thread는 항상 Background Thread가 실행시키는건 아니다.
  - 여러개의 Thread가 많이 돌고있을 때 --> handleMessage()로 실행

<br>

### Async Task(213-4p)

*TestThread.java*

- 비동기적인 작업(ex. 다운로드)에 많이 쓰인다.
- 내부적으로 알아서 쓰레드를 만들어준다.
- AsyncTask의 정체는 **핸들러**!

 ![asynctask에 대한 이미지 검색결과](http://www.lucadentella.it/blog/wp-content/uploads/2014/05/asynctask.jpg) 

1. 실행시키기 (`Oncreate()`에서)

   ```java
   new MyCountAsyncTask().execute(15);
   ```





<br>

### Network

- manifest에 permission주기

  ```xml
  <?xml version="1.0" encoding="utf-8"?>
  <manifest xmlns:android="http://schemas.android.com/apk/res/android"
      package="com.sm.testnetasync">
      <uses-permission android:name="android.permission.INTERNET"/>
  ```

- async test는 언제나 MainThread에서 돌려야한다.

- get방식 : 데이터를 가져올 때  
  post 방식 : 데이터를 폼에 입력하고, 입력된데이터를 DB에 저장할 때

- [어플리케이션(앱) 종류]( https://m.blog.naver.com/acornedu/221012420292 ) (--> 유지보수에 중요)  

  - 네이티브앱 : `HttpURLConnection`
    - 네이티브API를 이용
    - 성능이 좋다(해당 플랫폼에 최적화)
    - 단점 : 플랫폼에 종속적(안드로이드버전, IOS버전), 유지보수가 쉽지 않다.
  - 웹앱 : 모바일웹 + 네이티브웹 결합한 형태  
    : *'특정한 데이터를 어떤 기기에서나 볼 수 있게 한다.'*가 기본 개념
    - 표준에 맞게 작성 --> 표준에 맞는 브라우저에서 돌릴 수 있다. (Windows -> InternetExplorer)
    -  모든 기기와 브라우저에서 접근할 수 있다. 
    -  웹사이트를 보는 것이기 때문에 따로 설치할 필요가 없다. 
    - 유지보수가 용이하다.
    - 단점 : 장치제어를 할 수 없다. (웹 용이기 때문에), [반응형웹]( https://www.samsungsds.com/global/ko/support/insights/Responsive_web_1.html )개발이 어렵다.
  - 하이브리드앱 

- 저장방법

  1. File System
     - 입력이 시작되는 곳 : **Source** : file, keyboard
     - 출력되는 곳 : **Sync** : file, console
     - Node = Source+Sync
     - **NodeStream** : 입출력
       ex) Inputstream, OutputStream, ...
     - Processing Stream : 성능향상을 위해 NodeStream에 붙여 사용하는 것   
       ex) BufferedReader(char), BufferedInputStream(ByteStream), InputStreamReader(convert Byte to character),   
       ObjectInputStream, DataInputStream
  2. Preference
  3. Database(SQLite)
  4. Network (Serverside에 필요정보 저장)

<br>

<br>

- TextColor, Size 한번에 주기 (124p)

  ```xml
  style="@style/red15" <!-- layout -->
  
  <!-- styles.xml -->
  <style name="red15">
      <item name="android:textColor">#ff0000</item>
      <item name="android:textSize">15pt</item>
  </style>
  <style name="yellow15italic" parent="@style/red15"> <!-- 상속 -->
      <item name="android:textColor">#ffff00</item>
      <item name="android:textStyle">italic</item>
  </style>
  ```

- 위에 메뉴바 없애기

  ```xml
  <!-- styles.xml -->
  <style name="mytheme">        
      <item name="android:windowNoTitle">true</item>
  </style>
  
  <!-- AndroidManifest : MenuBar 없애기 옵션주기 -->
  <activity
            android:name="edu.jaen.android.res.theme.ThemeTest"
            android:theme="@android:style/Theme.DeviceDefault.NoActionBar.Fullscreen">
      
  <!-- AndroidManifest : Dialogue로 띄우기 -->
  <activity
            android:name="edu.jaen.android.res.theme.ThemeTest"
            android:theme="@android:style/Theme.Holo.Dialog">
  ```

  

### Options Menu

*GridViewTest* 어플리케이션

- Action Bar이용

  1. Java Code 이용

     ```java
     
     ```

     

  2. XML 이용

<br>

### Context Menu

- 길게 꾹~누르면 컨텍스트 메뉴가 팝업된다.
- View라면 어디든 달 수 있다.
- `onCreate()`에서 컨텍스트메뉴를 등록해줘야한다. `registerForContextMenu(button)`(버튼에 컨텍스트메뉴를 달겠다는 뜻)
- `onCreateContextMenu` ---> `onContextItemSelected()`가 콜백된다.



<br>

- 사용자에게 정보를 전달하는 방법

  1. Toast
  2. Dialogue
  3. Notification

- Builder Pattern : `AlertDialog.Builder` 계속 `AleartDialog.Builder`가 return 된다

  ```java
  return new AlertDialog.Builder(AlertDialogSamples.this)
      .setIcon(R.drawable.alert_dialog_icon)
      .setTitle(R.string.alert_dialog_text_entry)
      .setView(textEntryView)
      .setPositiveButton(R.string.alert_dialog_ok, new DialogInterface.OnClickListener() {
          public void onClick(DialogInterface dialog, int whichButton) {
  
              /* User clicked OK so do some stuff */
          }
      })
      .setNegativeButton(R.string.alert_dialog_cancel, new DialogInterface.OnClickListener() {
          public void onClick(DialogInterface dialog, int whichButton) {
  
              /* User clicked cancel so do some stuff */
          }
      }) // -> 여기까지 AleartDialog.Builder 리턴됨
      .create(); --> Dialogue 리턴됨
  ```

  - Notification 만들때 사용된다.